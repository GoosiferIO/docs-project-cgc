{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Project CGC Documentation This website was set up for any new developers who are interested in contributing to the project. The website is built using MkDocs , a static site generator that's geared towards project documentation. The website is hosted on GitHub Pages , and the source code can be found here . At the moment, the documentation is targeted towards programmers rather than design but other disciplines are welcome to contribute and add their own pages. Summer Team 2024 Game Design Nate Phae Petersen Madi Els Fouch\u00e9 Nico Production Arturo Armendaris-Ibarria Courtney Cochran Bryce Becerra Alice Porter Level Design Leland LeVassar 3D Art Nilo Miranda Programming Abraham Eric Galvan Jordan Sound Design Riley McBroome Linus Johanesson Jess 2D Art Symon","title":"Home"},{"location":"#project-cgc-documentation","text":"This website was set up for any new developers who are interested in contributing to the project. The website is built using MkDocs , a static site generator that's geared towards project documentation. The website is hosted on GitHub Pages , and the source code can be found here . At the moment, the documentation is targeted towards programmers rather than design but other disciplines are welcome to contribute and add their own pages.","title":"Project CGC Documentation"},{"location":"#summer-team-2024","text":"Game Design Nate Phae Petersen Madi Els Fouch\u00e9 Nico Production Arturo Armendaris-Ibarria Courtney Cochran Bryce Becerra Alice Porter Level Design Leland LeVassar 3D Art Nilo Miranda Programming Abraham Eric Galvan Jordan Sound Design Riley McBroome Linus Johanesson Jess 2D Art Symon","title":"Summer Team 2024"},{"location":"contributing/","text":"Contributing To get started with contributing to this project, please make sure you have access to the following tools: Project CGC Game Repository Miro Board Discord If you see a tool above you don't have access to, please contact the project manager or the team lead for the discipline you're interested in contributing to. Tools Required Unreal Engine 5.3.2 Github Feel free to use the Github Desktop app if you're not comfortable with the command line. Optional Visual Studio Code","title":"Contributing"},{"location":"contributing/#contributing","text":"To get started with contributing to this project, please make sure you have access to the following tools: Project CGC Game Repository Miro Board Discord If you see a tool above you don't have access to, please contact the project manager or the team lead for the discipline you're interested in contributing to.","title":"Contributing"},{"location":"contributing/#tools","text":"Required Unreal Engine 5.3.2 Github Feel free to use the Github Desktop app if you're not comfortable with the command line. Optional Visual Studio Code","title":"Tools"},{"location":"reference/","text":"Reference Guides This section intends to include information about miscellaneous topics that might help developers understand the Unreal Engine better. List of Important Unreal Engine Objects Unreal has several default objects that it must create in order to function, such as the game instance object. These objects have built-in functionality and it is often advantageous to create your own. Defaults can be modified in the edit -> project settings -> Project:Maps&Modes menu. Defaults can also be modified in the world settings menu (docked in the editor by default). Below is a table of the most important objects in Unreal Engine: Object Description Game Instance There is only one game instance per game. It's automatically created as the game is being initialized and isn't destroyed until the game ends. It is ideal for handling functionality that needs to be available at all times, such as save & load functionality. Game Mode The game mode handles various rules about the game. Uncertain: It seems only one game mode object can be active per map. In a networked game the game mode is non-replicable (e.g. server side only). Game State The game state generally handles data about the game. In a networked game this generally means holding things like team scores. Game states are replicated from the server to all clients. Player State The player state object generally handles data about the player such as player name and score. Player states are replicated from the server to all clients. This allows for things like displaying every player's score in an online FPS game. Player Controller The player controller handles setup of the controls for the player. This is generally where you would place functionality for changing controls based on context e.g. quicktime events, controlling a car vs. a character, etc. Player Pawn The player pawn is 'possessed' by the player who is, as the name implies, a disembodied concept unless possessing a pawn. Pawns can be characters with a visually displayed mesh, a car, plane, whatever. Pawns generally have a camera component and a mesh. Individual pawns handle the implementation of the control scheme as defined in the player controller. This way you can allow a player to swap from one pawn to another and have many or all of the same controls shared but with differing implementations as needed.","title":"Reference Guides"},{"location":"reference/#reference-guides","text":"This section intends to include information about miscellaneous topics that might help developers understand the Unreal Engine better.","title":"Reference Guides"},{"location":"reference/#list-of-important-unreal-engine-objects","text":"Unreal has several default objects that it must create in order to function, such as the game instance object. These objects have built-in functionality and it is often advantageous to create your own. Defaults can be modified in the edit -> project settings -> Project:Maps&Modes menu. Defaults can also be modified in the world settings menu (docked in the editor by default). Below is a table of the most important objects in Unreal Engine: Object Description Game Instance There is only one game instance per game. It's automatically created as the game is being initialized and isn't destroyed until the game ends. It is ideal for handling functionality that needs to be available at all times, such as save & load functionality. Game Mode The game mode handles various rules about the game. Uncertain: It seems only one game mode object can be active per map. In a networked game the game mode is non-replicable (e.g. server side only). Game State The game state generally handles data about the game. In a networked game this generally means holding things like team scores. Game states are replicated from the server to all clients. Player State The player state object generally handles data about the player such as player name and score. Player states are replicated from the server to all clients. This allows for things like displaying every player's score in an online FPS game. Player Controller The player controller handles setup of the controls for the player. This is generally where you would place functionality for changing controls based on context e.g. quicktime events, controlling a car vs. a character, etc. Player Pawn The player pawn is 'possessed' by the player who is, as the name implies, a disembodied concept unless possessing a pawn. Pawns can be characters with a visually displayed mesh, a car, plane, whatever. Pawns generally have a camera component and a mesh. Individual pawns handle the implementation of the control scheme as defined in the player controller. This way you can allow a player to swap from one pawn to another and have many or all of the same controls shared but with differing implementations as needed.","title":"List of Important Unreal Engine Objects"},{"location":"style-guide/","text":"Style Guide Unreal Engine has a particular convention for naming files, variables, and functions. This style guide is a reference for the naming conventions used in this project. To be sure, you're reading the spark notes version of the official Unreal Engine Style Guide. Please skip to #Conclusion for links to sources. Copyright Notice Make sure all source files have the following notice at the top of the file: // Copyright Team CGC. All Rights Reserved. It must match the exact format above. Naming Conventions General Rules Make sure that all names start with a capital letter. No underscores between words. Correct : int MyVariable; class MyClass; Incorrect : int myVariable; class my_class; class myClass; Boolean Variables Though an initial capital letter is usually fine, boolean variables specifically diverge a bit from this rule. All booleans should start with \"b\" and then have an initial capital letter. Correct : bool bIsTrue; Incorrect : bool IsTrue; Classes Unreal Engine has certain conventions for certain types of asset classes. Objects, Actors, Widgets, and Interfaces require a prefix to their name. Generalized Example class UMyObject; class AMyActor; class UMyWidget; class IMyInterface; Objects should always start with a \"U\", Actors with an \"A\", Widgets with a \"U\", and Interfaces with an \"I\". Other classes should start with \"F\". Typedefs Typedefs are denominations given to a type to make it easier to read and understand. Typedefs should start with an \"F\" if they are a struct or a \"U\" if they are an object. Names and Grammar Names should be descriptive and follow the rules of the English language. For example, a variable that holds the value of a player's health should be named \"PlayerHealth\" and not \"PercentageValue\", as a simple example. Types and variables should also be nouns, and method names should be verbs that describe the action they perform. Correct : int PlayerHealth; // A variable that holds the player's health. void UpdateHealth(); // A method that updates the player's health. Incorrect : int PercentageValue; // A bad example of a variable that holds the player's health. void Health(); // A bad example of a method that updates the player's health. Booleans All booleans should be named as though it were a question. Examples bool bIsTrue; // A boolean that asks if something is true. bool bIsDead; // A boolean that asks if something is dead. Assets Naming conventions for assets are a bit different from the naming conventions for code. Assets should be named in a way that makes them easy to find and understand. Unreal suggests the following convention for naming files: [AssetTypePrefix]_[AssetName]_[Descriptor]_[OptionalVariantLetterOrNumber] AssetTypePrefix : A prefix that indicates the type of asset. For example, \"SM\" for a static mesh, \"T\" for a texture, \"M\" for a material, and so on. AssetName : A descriptive name for the asset. For example, \"Wall\", \"Floor\", \"Player\", and so on. Descriptor : A descriptor that describes the asset. For example, whether \"a texture is a normal map or an opacity map\". OptionalVariantLetterOrNumber : An optional letter or number that distinguishes the asset from other assets of the same type. Examples SM_Wall_01 T_Wall_Normal M_Wall_Brick For a full list of recommended prefixes, please refer to the Recommended Asset Naming Conventions . Conclusion Following the style guide is essential to maintain consistency in the project and ensures that other contributors can easily understand the code. Outlined above is a brief overview and in no means exhaustive, but will likely be expanded upon should the need arise. For a more detailed guide, please refer to the Unreal Engine Style Guide .","title":"Style Guide"},{"location":"style-guide/#style-guide","text":"Unreal Engine has a particular convention for naming files, variables, and functions. This style guide is a reference for the naming conventions used in this project. To be sure, you're reading the spark notes version of the official Unreal Engine Style Guide. Please skip to #Conclusion for links to sources.","title":"Style Guide"},{"location":"style-guide/#copyright-notice","text":"Make sure all source files have the following notice at the top of the file: // Copyright Team CGC. All Rights Reserved. It must match the exact format above.","title":"Copyright Notice"},{"location":"style-guide/#naming-conventions","text":"","title":"Naming Conventions"},{"location":"style-guide/#general-rules","text":"Make sure that all names start with a capital letter. No underscores between words. Correct : int MyVariable; class MyClass; Incorrect : int myVariable; class my_class; class myClass;","title":"General Rules"},{"location":"style-guide/#boolean-variables","text":"Though an initial capital letter is usually fine, boolean variables specifically diverge a bit from this rule. All booleans should start with \"b\" and then have an initial capital letter. Correct : bool bIsTrue; Incorrect : bool IsTrue;","title":"Boolean Variables"},{"location":"style-guide/#classes","text":"Unreal Engine has certain conventions for certain types of asset classes. Objects, Actors, Widgets, and Interfaces require a prefix to their name. Generalized Example class UMyObject; class AMyActor; class UMyWidget; class IMyInterface; Objects should always start with a \"U\", Actors with an \"A\", Widgets with a \"U\", and Interfaces with an \"I\". Other classes should start with \"F\".","title":"Classes"},{"location":"style-guide/#typedefs","text":"Typedefs are denominations given to a type to make it easier to read and understand. Typedefs should start with an \"F\" if they are a struct or a \"U\" if they are an object.","title":"Typedefs"},{"location":"style-guide/#names-and-grammar","text":"Names should be descriptive and follow the rules of the English language. For example, a variable that holds the value of a player's health should be named \"PlayerHealth\" and not \"PercentageValue\", as a simple example. Types and variables should also be nouns, and method names should be verbs that describe the action they perform. Correct : int PlayerHealth; // A variable that holds the player's health. void UpdateHealth(); // A method that updates the player's health. Incorrect : int PercentageValue; // A bad example of a variable that holds the player's health. void Health(); // A bad example of a method that updates the player's health.","title":"Names and Grammar"},{"location":"style-guide/#booleans","text":"All booleans should be named as though it were a question. Examples bool bIsTrue; // A boolean that asks if something is true. bool bIsDead; // A boolean that asks if something is dead.","title":"Booleans"},{"location":"style-guide/#assets","text":"Naming conventions for assets are a bit different from the naming conventions for code. Assets should be named in a way that makes them easy to find and understand. Unreal suggests the following convention for naming files: [AssetTypePrefix]_[AssetName]_[Descriptor]_[OptionalVariantLetterOrNumber] AssetTypePrefix : A prefix that indicates the type of asset. For example, \"SM\" for a static mesh, \"T\" for a texture, \"M\" for a material, and so on. AssetName : A descriptive name for the asset. For example, \"Wall\", \"Floor\", \"Player\", and so on. Descriptor : A descriptor that describes the asset. For example, whether \"a texture is a normal map or an opacity map\". OptionalVariantLetterOrNumber : An optional letter or number that distinguishes the asset from other assets of the same type. Examples SM_Wall_01 T_Wall_Normal M_Wall_Brick For a full list of recommended prefixes, please refer to the Recommended Asset Naming Conventions .","title":"Assets"},{"location":"style-guide/#conclusion","text":"Following the style guide is essential to maintain consistency in the project and ensures that other contributors can easily understand the code. Outlined above is a brief overview and in no means exhaustive, but will likely be expanded upon should the need arise. For a more detailed guide, please refer to the Unreal Engine Style Guide .","title":"Conclusion"}]}